# C++面经 #

> [常见C++面试题，大厂经典C++面试题](https://zhuanlan.zhihu.com/p/388332799)


# C++11 标准 #

## 关键词和语法 ##

1. auto：根据右值推导出类型，
2. nullptr：给指指针专用， #defin NULL 0
3. foreach：遍历数组和容器等
4. 右值引用：move和forward
5. 模板特性：typename... A 标识可变参数

## 绑定器和函数对象 ##

1. function：函数对象
2. bing：绑定器 bind1st和bind2st+二元函数对象 =》 一元函数的对象
3. lambda表达式

## 智能指针 ##

1. shared_ptr和weak_ptr
 
## 容器 ##

1. set和map：红黑树
2. unordered_map和unordered_set：哈希表
3. array：固定数组
4. forwad_list：前向链表

## C++语言级别支持的多线程编程 ##

1. createTread
2. pthread_create
3. clone

## 对象优化 ##

1. 函数传参过程中，对象优先按照引用传递，不要按照值传递
2. 函数返回对象的时候，应该优先返回临时对象，而不是返回一个定义过的对象；这是因为编译器会优化临时对象拷贝构造同类型的新对象
3. 接收返回值是对象的函数调用的时候，优先按照初始化方式接收，不要按赋值的方式接收


左值和右值引用

左值有名字,有内存;右值没名字,没内存

模板参数统一两种引用,使用到引用折叠

	template<typename Ty>
	void push_back(Ty &&val) & + && = & | && + && = &&
	std::forward<Ty>(val) 类型完美转发


函数对象,重载小括号()

结合函数模板(泛型)来实现

1. 绑定器,bind1st,bind2st,将二元函数对象用作一元函数对象
2. function,区分函数类型和函数指针类型
3. lambda表达式\[捕获外部变量](形参列表)->返回值{操作代码}

## C++ 多线程 ##

代码可以跨平台

1. thread/mutex/condition_variable
2. lock_guard/unique_lock
3. automic 原子类型 基于 CAS 操作的原子类型 线程安全的
4. sleep_for

### 线程内容 ###

1. 怎么创建启动一个线程 ==》 std::thread定义一个线程对象，传入线程所需要的线程和函数和参数，线程自动启动
2. 子线程如何结束 ==》 子线程函数运行结束，线程就结束了
3. 主线程如何处理子线程 ==》 join主线程等待子线程结束；detach设置分离线程，主线程结束，整个进程结束，所有子线程自动结束

### 线程间的互斥 ###

1. 线程间互斥 =》 临界区代码段 =》 保证原子操作 =》 互斥锁mutex =》 lock_guard封装mutex，出作用域自动析构（解锁）
2. 竞态条件：多线程程序执行结果是一致的，不会随CPU对线程不同的调用顺序影响，产生不同的运行结果
3. 锁+双重判断

### 线程间的同步通信 ###

condition_variable wait和notify_all方法，通知在cv上等待的线程，起来干活；收到通知后，从等待状态 =》 阻塞状态 =》 获取互斥锁 =》 继续执行

### 原子操作 ###

1. 互斥锁比较重的，临界区代码做的事情稍稍复杂
2. 系统理论：CAS类保证操作的原子特性就足够了，无锁操作
3. atomic类型变量，如atomic_int；使用volatile修饰变量，防止多线程对变量进行缓存

## 编程模式 ##

封装对象的创建

### 单例模式 ###

定义：一个类不管创建多少次对象，永远只能得到该类型一个对象的实例，如日志模块、数据库模块

1. 构造函数私有化，包括拷贝构造和赋值构造
2. 定义一个唯一的类的静态实例对象
3. 获取类的唯一实例对象的接口方法

- 饿汉式单例模式：还没有获取实例对象，实例对象已经产生了
- 懒汉式单例模式： 唯一的实例对象，直到第一次获取他的时候才产生

懒汉式单例模式使用互斥锁+双重判断保证线程安全

两种实现方式

1. if判断静态对象的指针是否为空
2. getInstance时候初始化静态变量，只会被初始化一次，且编译器会为构造函数添加互斥锁

### 工厂模式 ###

简单工厂（Simple Factory）：使用额外的Factory类，封装多个子类的实例化方法，通过定义枚举来区分；不符合软件的“开-闭”原则（对已有功能封闭，对扩展开放）
工厂方法（Factory Method）：给一个工厂的基类定义一个纯虚函数，实现不同工厂的子类，符合软件的“开-闭”原则；但是一个产品就需要一个工厂
抽象工厂（Abstract Factory）：对有一组关联关系的产品簇提供产品对象的统一创建，即抽象工厂类中包含多中产品的创建接口


### 代理模式 ###

> 结构模式,组合类的继承关系

通过代理类来控制实际对象的访问权限

抽象类 => 委托类 => 代理类 <= 抽象类

委托类实现了代理类的所有功能,代理类继承紫抽象类,并且其中包含一个委托类的对象,实现对委托类的访问控制

### 装饰器模式 ###

增加现有类的功能,一个办法是新增加一个子类,但是代码中的子类太多

抽象类 => 委托类
抽象类 => 装饰器基类 => 装饰器 <= 委托类指针

### 适配器模式 ### 

让不兼容的接口可以一起工作,如接口转换

适配器继承老接口,其中包含一个新接口的对象,对于老接口方法的调用,将会调用适配器中新街口对象的方法

### 观察者/监听者/发布-订阅模式 ###

> 行为模式

主要关注对象之间的通信，关注的对象是一对多的关系，也就是都依赖一个对象，当该对象发生改变时，其他对象都能够接收到相应的通知

观察者通过一个map记录对象感兴趣的事件，并通知对象执行方法


## 智能指针 ##

unique_ptr不带引用计数的ptr

引用计数RefCnt *ref存储 uses和weaks；weak_ptr观察uses但不修改；一旦uses减到0，释放数据空间，weaks减到0，释放引用计数空间

推荐使用make_shared<int>(10)， 而不是share_ptr(new int(10))，前者可以把需要托管的对象和存储有引用计数的内存资源一起开辟，放在一块内存上；后者需要开辟两个内存空间，存在内存泄露的风险；

make_shared优点：

1. 内存分配效率高
2. 防止资源泄露风险

make_shared缺点

1. 无法自定义删除器，默认使用delete，像文件的close就不能使用
2. 导致托管的资源延迟释放，只有当uses和weaks都为0时，托管对象和引用计数才会一起被释放

## emplace方法 ##

C++11 STL 容器为所有的 push/insert 定义了 新的emplace方法

直接插入对象，两者没有区别；emplace传入对象构造所需要的参数，直接再容器底层构造对象即可，省去了拷贝构造


# C++面经 #

> 面试官提出问题，不要着急作答，整理逻辑思路
> 
> 对于简单问题，不要照本宣科，找准问题回答的角度/层次，争取有亮点，引到自己准备的领域，如编译链接
> 
> 对于复杂问题，花时间思考，整理好逻辑思路，以及问题大致描述的顺序。现场面试，使用笔纸边讲边画；电话面试，回答问题过程中，需要经常跟面试官沟通
> 
> 被问到自己不知道的内容，保证回答饱满，说一些可能相关的；拓展知识广度；往自己了解的方面引导
> 
> 你还有什么问题，将来在公司用到的技术有哪些，对面试点评提建议

1. C++的this指针干什么用的？
	> 一个类型=》很多对象+》私有成员变量共享一套成员方法=》确定操作的哪个对象的成员
2. C++的new和delete，什么时候用new[]申请必须用delete释放
	> new delete释放 =》 调用析构函数，释放内存
	> 
	> 如果是自定义类型，有析构函数，使用new Test[10]就一定需要匹配delete []ptr，会额外开辟四字节记录对象数量
3. C++的static关键字的作用（从elf结构、链接回答）
	> static可以修饰全局变量、函数和局部变量
	> 
	> 全局变量和函数被static修饰后，在符号表中作用域就从g变成l
	> 
	> static修饰局部变量存储到 .data.bss段落，本身产生符号，通过ebp-偏移量来访问
	> 
	> 面向对象的角度：static可以修饰成员变量，修饰成员方法
4. C++继承
	> 属于类与类之间的关系，还有组合关系
	> 
	> 通过继承，在基类中给所有派生类保留统一的纯虚函数接口，等待派生类重写，通过多态，可以通过基类指针访问不同派生类对象的同名覆盖方法
5. C++的继承多态，空间配置器，vector和list区别，map，多重map
	> 多态：静多态（编译时期）：函数重载和模板；动多态（运行时期）：虚函数 指针/引用指向派生类对象
	> 
	> 空间配置器allocator：给容器使用，主要作用是把对象的内存开辟和对象构造分开，把对象的析构和内存释放分开
	> 
	> vector和list的区别：数组和链表
	> 
	> map：映射表，key-val，底层实现红黑树；multimap允许key重复
	> 
	> 红黑树的五个性质，插入三种情况和删除四种情况
6. C++如何防止内存泄露？智能指针
	> 内存泄露：分配的堆内存（没有名字，只能用指针指向）没有释放，也在没机会释放了
	> 
	> 智能指针：栈上对象出作用域自动析构；auto_ptr/scoped_ptr/unique_ptr, shared_ptr/weak_ptr
7. C++如何调用C语言
	> C和C++生成的符号方式不一样，API不饿能直接调用，C语言的函数声明必须在extern "C" {}中
8. C++什么情况出现访问越界
	> 访问数组元素、vector、string、字符串（没有\0）、类型强转（大类型指针指向小内存，如派生类->基类）
9. C++类的初始化列表
	> 指定对象成员变量的初始化方式，尤其执行成员对象的构造方式
10. C++和C内存分布的区别
	> C++和C的区别：引用、函数重载、new/delete malloc/free、const inline 带默认参数的函数、模板、类和对象（OOP）、STL、异常、智能指针、运算符重载
	> 内存分布：没有区别
11. C++ int* const p和 const int *p区别
	> 前者修饰指针p不能修改，但是*p可以修改；后者*p不能修改，指针p可以修改
12. C++malloc和new的区别
	> malloc按字节开辟内存，new底层调用malloc开辟内存，但还可以提供初始化
	> malloc开辟失败返回nullptr，new开始失败抛出bad_alloc类型异常
	> malloc C的库函数，new是操作符
	> malloc单个/数组都一样，指定空间大小，new int(10); new int[20];
13. C++map和set的实现原理
	> set集合，只存key；map映射表，存储key-val，都是通过红黑树实现，avl树和红黑树区别
14. C++shared_ptr引用计数存放在哪里
	> 堆上分配
15. C++STL
	> 标准容器 =》 顺序容器（vector、deque、list） =》 容器适配器（stack、queuq、priority_queuq） =》 关联容器（有序和无序）
	> 
	> 近容器、数组、string、bitset
	> 
	> 迭代器
	> 
	> 泛型算法
	> 
	> 函数对象 sort find_if
16. C++迭代器失效
	> 不允许一边读一边修改
17. C++STL哪些红黑树实现
	> set/multiset/map/multimap
18. C++struct和class的区别
	> 定义、继承、空结构体和空类、C++11结构体初始化的DATA data={10， 11}、class可以定义模板参数
19. C++编译链接
	> 预处理、编译、汇编 => 可重定位文件
	> 
	> 链接：合并段、符号解析、符号重定向 =》 可执行文件
20. C++初始化变量和未初始化变量存储位置
	> 数据段和bss段
21. C++堆栈的区别
	> 堆大小 >> 栈内存，手动分配和自动分配/回收，增长方向
22. C++构造函数和析构函数是否可以为虚函数，能够抛出异常
	> 构造函数不可以，析构函数可以。虚函数表；构造函数不能抛出异常，对象创建失败就不能调用对象的析构函数，析构函数也不应该抛异常
23. C++宏和内联函数的区别
	> 预编译节点（字符串替换）；编译阶段（函数代码展开），内联可以调试
24. C++局部变量存放在哪里
	> stack ebp指针偏移来访问，不产生符号，.text
25. C++拷贝构造为什么传引用而不传值
	> 传值过程中实参到形参本身就需要拷贝构造
26. C++实现一个不可以被继承的类
	> 派生类初始化过程：基类构造 =》 派生类构造，因此将构造函数私有化即可
27. C++纯虚函数，为什么要有纯虚函数，虚函数表放在哪里
	> virtual void func()=0，用在抽象类中，不能实例化对象，可以定义指针和引用；虚函数表在编译阶段产生，运行时加载到.rodata段
28. C++手写单例模式
29. C++const和static的区别
	> const编译方式：把出现常量名字的地方，用常量的值进行替换
	> 
	> const可以修饰全局变量、局部变量、形参变量；static：全局变量、局部变量
	> 
	> const不能修饰函数 static可以
	> 
	> const：常方法/成员变量 static：静态方法/成员变量，不依赖于对象
30. C++四种强制类型转换
	> const_cast 去掉常量属性
	> 
	> static_cast 编译器认为安全的转换
	> 
	> reinterpret_cast C风格的类型转换，不安全
	> 
	> dynamic_cast 支持RTTI信息识别的类型转换，基类指针转为派生类指针，识别
31. C++详细解释deque的底层原理
	> 动态开辟的二位数组，双端队列，两端都有队头队尾，一维数组的初始大小 MAP_SIZE（T*），第二位数组默认
	> 
	> 扩容？
32. C++虚函数，多态
	> 一个类 =》 虚函数 =》 编译阶段 =》 产生虚函数表 =》 运行时加载到.rodata
	> 
	> 指针或引用 =》 调用虚函数 =》 指针访问对象的头四个字节vfptr =》 vftable中去除虚函数的地址，进行动态绑定调用
	> 
	> 多态：设计函数接口，可以都使用基类的指针或引用来接受不同的派生类对象，功能增加，删除；设计模式
33. C++异常机制
34. C++早绑定和晚绑定
	> 早绑定（静态）：普通函数的调用，用对象调用虚函数call编译阶段就已经直到调用哪个函数
	> 
	> 晚绑定（动态）：指针/引用调用虚函数的时候，都是动态绑定 p->vfptr->vftable->virtaul addr =》call eax
35. C++指针和引用的区别(反汇编分析)
	> 指针和引用在回汇编层面一样
36. C++智能指针交叉引用问题
	> 定义对象使用强智能指针shared_ptr，引用对象使用弱智能指针weak_ptr
	> 发的
	> 当通过weak_ptr访问兑现成员时，需要先调用lock提升方法，提升为强智能指针，在进行对象成员调用，若提升失败说明对象已经被delete
37. C++重载的底层实现，虚函数的底层实现
	> C++生成函数符号依赖于函数名字+参数列表；编译到函数调用点时，根据函数名字和传入的实参（个数和类型），和某一个函数重载匹配的化，直接调用响应的函数重载版本
	> 
	> 虚函数 =》 对象 指针/引用 =》 vfptr =》 vftable =》 虚函数地址 call eax
38. C++假设map的键是类，map底层如何调整
	> 需要类实现 operator<运算符重载


# 简历 #

1. 求职意向，不同公司不同岗位要求和名称不一样，需要调整
2. 简历文件命名，按照要求命名
3. 技能描述（必写），包括语言、操作系统、协议、网络和多线程、数据结构和算法、数据库、框架类、开源代码剖析、服务器中间件的使用等；描述体现知识的深度和广度，熟练xxx，具体描述怎么熟练
	1. 语言：熟练C/C++语言，熟悉C的指针应用和内存管理，C++的继承多态、STL库的各种容器、智能指针、C++11的常用特性、常用的设计模式（单例、工厂）
	2. 操作系统：Linux的虚拟内存管理、进程线程调度、进程间通信、线程的互斥和同步通信、虚拟地址映射机制
	3. 协议：TCP/IP、UDP、HTTP、ARP、三次握手、四次挥手、容错处理、拥塞控制、滑动窗口、网络和多线程
	4. 网络和多线程:TCP和UDP编程，数量Linux系统的IO服用接口、select、pool和epoll（ET/LT模式）、libevent（开源网络库）；fork、clone、pthread、信号量、互斥锁/读写锁/自旋锁/CAS
	5. 数据结构和算法：熟练线性表（链表、栈、队列）、常用排序算法（快排）、hash表、BST、AVL、红黑树
	6. 数据库：熟悉MySQL常用SQL、索引以及优化、索引的底层实现、事务处理（ACID和隔离级别）、日志系统
	7. 框架类：
	8. 开源代码剖析：SGI STL空间配置器、nginx内存池、muduo、libevent、redis、memcache、zookeeper、avtivemq
4. 项目经验
	1. 重复度低名字
	2. 开发系统工具，辅助测试开发工具
	3. 体现设计思想、计数开个你家、采用的第三方库、中间件产品等，尽量少做业务描述
	4. 问题难点
5. 个人评价
	1. 优秀学习能力
	2. 一定的抗压能力
	3. 团队写作能力
	4. 对自己的职业有一定的规划
	5. 积极的学习生活态度


# STL #

> [学习C++之STL，看这篇就够啦](https://blog.csdn.net/weixin_72707764/article/details/130905139)